import java.util.Random;
import java.util.Scanner;

public class Driver {

	//Declare static variables to be used in markov chain algorithms
	private static Scanner sc = new Scanner(System.in);
	private static Channel[] allChannels;
	private static boolean[] currentStates;
	private static int channelsRemaining;
	private static Random rand;
	private static int totalRuns = 0;
	private static int trials = 100;
	
	public static void main(String[] args) 
	{
		//Prompt user for number of channels
		System.out.println("Enter the number of channels");
		int numChannels = sc.nextInt();
		
		//Keep all arrays this size
		allChannels = new Channel[numChannels];
		currentStates = new boolean[numChannels];
		
		//Get random seed for repeatability
		System.out.println("Enter the randomseed number");
		int randomseed = sc.nextInt();
		rand = new Random(randomseed);
		int iterator = 0;
		
		//Declare all channels with another randomseed randomly generated by this randomseed
		
		for(int i = 0; i < numChannels; i++)
		{
			allChannels[i] = new Channel(rand.nextInt(100));
			currentStates[iterator] = true;
			iterator++;
		}
		
		//If there are only two channels, override random and rig the channels
		//Temporary Solution until command line arguments are implemented
		if(numChannels == 2)
		{
			riggedSolution();	
		}
		
		int port = 0;
		
		for(int i = 0; i < numChannels; i++)
		{
			//Print their information
			System.out.println("Port number " + port + ": "
					+ 			"\nChance of staying in success: " + allChannels[i].getSTAY_SUCCESS() + 
								"\nChance of staying in failure: " + allChannels[i].getSTAY_FAILURE());
			port++;
		}
		
		boolean isDone = false;
		channelsRemaining = numChannels;
		
		while(!isDone)
		{
			totalRuns++;	//Increase run number each time we loop through entire remaining group of channels
			for(int i = 0; i < allChannels.length; i++)
			{
				//If successful, add to growing tally of remaining channels we wish to analyze, else, keep it the same.
				if(currentStates[i])
				{
					currentStates[i] = allChannels[i].ping();
					if(!currentStates[i]) 
						{
							channelsRemaining--;
							System.out.println("Channel: " + i + " Removed on run " + totalRuns);
						}
				}
			}
			
			if(channelsRemaining == 0 | totalRuns >= trials)
			{
				isDone = true;
			}
			
		}
		
		int bestRateIndex = 0;
		int mostSuccessIndex = 0;
		double bestRate = 0;
		int mostSuccess = 0;
		
		for(int i = 0; i < allChannels.length; i++)
		{
			
			//Get the greatest Stay Success Rate from all channels
			double currRate = allChannels[i].getSTAY_SUCCESS();
			if( currRate > bestRate)
			{
				bestRate = currRate;
				bestRateIndex = i;
			}
			
			//Get the channel with the most successes
			int numSuccess = allChannels[i].getSuccesses();
			if(numSuccess > mostSuccess)
			{
				mostSuccess = numSuccess;
				mostSuccessIndex = i;
			}
		}
		
		System.out.println();
		System.out.println("Total Runs:" + totalRuns);
		System.out.println("Channel with bast STA_SUCCESS rate: Channel " + bestRateIndex + "\nRate: " + bestRate);
		System.out.println("Channel with most successes (we pick): Channel " + mostSuccessIndex + "\nSuccesses: " + mostSuccess + " out of " + totalRuns);	
	}
	
	public static void riggedSolution()
	{
		
		//Channel 0 is rigged to win, Channel 1 is rigged to lose
		allChannels[0].setSTAY_SUCCESS(0.95);
		allChannels[0].setSTAY_FAILURE(0.05);
		
		allChannels[1].setSTAY_SUCCESS(0.05);
		allChannels[1].setSTAY_FAILURE(0.95);
		
		currentStates[0] = true;
		currentStates[1] = true;
	}
}

